---
title: 简单认识G1收集器
categories:
- Java
tags:
- JVM
- GC
---

- 简介
- 堆内存结构
- Region
- GC过程
<!--more-->


# 简介
[https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html](跳转至官网查看G1收集器详细介绍)
在JDK 6u14版本作为体验版面世。
在JDK 7u4版本发行时被正式推出。
在JDK 9中被设置为默认垃圾收集器（JEP 248）。

在官网中描述： 
> The Garbage-First (G1) collector is a server-style garbage collector, targeted for multi-processor machines with large memories. It meets garbage collection (GC) pause time goals with a high probability, while achieving high throughput. The G1 garbage collector is fully supported in Oracle JDK 7 update 4 and later releases. The G1 collector is designed for applications that: 
> * Can operate concurrently with applications threads like the CMS collector. 
> * Compact free space without lengthy GC induced pause times. 
> * Need more predictable GC pause durations. 
> * Do not want to sacrifice a lot of throughput performance. 
> * Do not require a much larger Java heap.

G1是一种服务器端的垃圾收集器，应用在多处理器和大容量内存环境中，在实现高吞吐量的同时，尽可能的满足垃圾收集暂停时间的要求。它是专门针对以下应用场景设计的: 
* 能与应用程序线程并发执行，和CMS一样。 
* 整理空闲空间更快。 
* 需要GC停顿时间更好预测。 
* 不希望牺牲大量的吞吐性能。 
* 不需要更大的Java Heap。

G1收集器的设计目标是取代CMS收集器，它同CMS相比，在以下方面表现的更出色： 
* G1是一个有整理内存过程的垃圾收集器，不会产生很多内存碎片。 
* G1的Stop The World(STW)更可控，G1在停顿时间上添加了预测机制，用户可以指定期望停顿时间。

# 堆内存结构
## serial & parallel & CMS 分代
新生代：一块地址连续的空间，Eden空间和两个Survivor空间，默认比例8:1:1，Java堆。
老年代：一块地址连续的空间，Java堆。
永久代：JDK8之前，一块地址连续的空间，HotSpot用永久代实现方法区，非堆。
元空间：JDK8移除永久代，部分数据移至堆，由元空间实现方法区保存类的元信息，使用本地内存。

## G1堆分配
一块堆空间，切分为大小相等的区域。
各区域和旧收集器一样有角色（eden、survivor、old），但不是固定大小的分配，参数配置范围内按需分配。
角色是逻辑连续，不是物理空间的连续。
堆分配Region区域，默认划分2048个，大小范围是1M~32M，参数-XX:G1HeapRegionSize指定区域大小。
可指定堆空间大小-Xms/-Xmx，避免指定-Xms，由JVM在GC时自动调整，通过增加堆大小可降低GC频率，如果指定了-XX:NewRatio、-Xms则参数-XX:MaxGCPauseMillis=200无效。
年轻代初始空间-XX:G1NewSizePercent(默认5%)
年轻代最大空间-XX:G1MaxNewSizePercent(默认60%)

## G1角色分配
Regina区域分配为eden、survivor、old，以及Humongous大对象区域。
对象达到Region区域的50%或更大时，放入连续空间的Humongous区域。
各角色的区域不用连续。

# GC
## Humongous Region
对象大小达到单个Region的一半称为巨型对象。
保存巨型对象的一个或多个连续区域称为巨型区域。
逻辑上Humongous区域属于老年代。
一旦没有引用指向巨型对象，可直接在YGC中回收。

## STAB算法
创建对象图逻辑快照，由缓冲区记录变更。
每个线程独占一个SATB缓冲区，用尽时写入全局缓冲区列表中，重新分配新的缓冲区。
在并发标记阶段定期检查处理全局缓冲区列表，扫描引用字段更新RSet。

## Remember Sets
每个区域都有RSet，记录其他区域引用了该区域对象的卡片索引。
回收时通过扫描RSet确定对象存活情况。
记录谁引用了我的对象，point-into。

## Card
每个区域内部划分为512字节的Card，最小可用粒度，对象会占用物理连续多个Card。
Card会记录在Global Card Table中。
记录我引用了谁的对象，point-out。

## Global Card Table
记录所有区域的卡片。

## Collection Sets
CSet分为YGC和混合GC两种。
收集每次回收的目标区域。

- YGC的CSet
收集年轻代里所有Region区域。

- 混合GC的CSet
启发式算法，在老年代候选回收区域中，筛选出回收收益最高的区域添加到CSet中。
收集年轻代里所有Region区域 + 全局并发标记阶段选出的Region区域。

## Young GC阶段
当JVM分配对象到eden区失败时，触发STW的YGC。
eden区晋升survivor区，survivor区达到年龄阈值晋升老年代。
GC阶段STW，所有应用线程停止。
并行收集，-XX:ParallelGCThreads设置并行收集线程数。
扫描root集合，垃圾收集的起点。


## Old GC阶段
全局并发标记阶段。
| Phase	| Description |
| :---- | :---------- |
| (1) Initial Mark (Stop the World Event)	| This is a stop the world event. With G1, it is piggybacked on a normal young GC. Mark survivor regions (root regions) which may have references to objects in old generation.
| (2) Root Region Scanning	| Scan survivor regions for references into the old generation. This happens while the application continues to run. The phase must be completed before a young GC can occur.
| (3) Concurrent Marking	| Find live objects over the entire heap. This happens while the application is running. This phase can be interrupted by young generation garbage collections.
| (4) Remark (Stop the World Event)	| Completes the marking of live object in the heap. Uses an algorithm called snapshot-at-the-beginning (SATB) which is much faster than what was used in the CMS collector.
| (5) Cleanup (Stop the World Event and Concurrent)	| <li>Performs accounting on live objects and completely free regions. (Stop the world) </li><li>Scrubs the Remembered Sets. (Stop the world)</li><li>Reset the empty regions and return them to the free list. (Concurrent)</li>
| (*) Copying (Stop the World Event)	| These are the stop the world pauses to evacuate or copy live objects to new unused regions. This can be done with young generation regions which are logged as [GC pause (young)]. Or both young and old generation regions which are logged as [GC Pause (mixed)]. |

### 初始标记阶段
- 属于YGC。
- STW。
- 初始标记新生代survivor区域的存活对象，可能引用了老年代对象。

### 扫描root区域
- YGC前完成。
- 和应用线程并发。
- root区域即是survivor区域，扫描survivor区中引用了老年代对象的区域。

### 并发标记阶段
- 可被YGC打断。
- 和应用线程并发。
- 计算存活对象信息。
- 存活信息用于确认哪些region区域更好的被回收。
- 全空region区域会在重新标记阶段立即移除为待分配区域。

### 重新标记阶段
- STW。
- 移除回收全空region区域。（为何存在空region区域，何时被清除了对象，只清除对象不移除区域吗）
- SATB算法。
- 完成存活对象的标记。

### 清除阶段
- STW和并发都有。
- 选择存活对象最少的区域，这些区域被回收最快（复制至新区域，量少最快）。
- 回收期间允许Young GC，混合GC阶段，日志[GC pause (mixed)]。
- 计算存活对象和全空区域，擦除RSet，重置空区域放回空闲列表。

### 复制阶段
- STW。
- TODO



疑问
1、混合GC的场景，如何控制年轻代和老年代之间并发
2、区域移除对象时，是否会删除区域角色
3、标记阶段是否区分年轻代和老年代，何时只标记老年代，何时只标记年轻代，标记的作用是什么

# 引用
https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html
https://tech.meituan.com/2016/09/23/g1.html
https://blog.csdn.net/coderlius/article/details/79272773
