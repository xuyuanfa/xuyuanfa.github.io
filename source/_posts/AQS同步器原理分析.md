---
title: AQS同步器原理分析
categories:
- Java
tags:
- JUC
- 同步锁
---






- [了解AQS](##1)
- [AQS实现基础](##2)
- [独占锁实现](##3)
- [共享锁实现](##4)
- [独占锁与共享锁最大的区别](##5)
- [获取锁的一些区别](##6)
- [条件协作](##7)
- [链表入队实现](##8)
<!--more-->



<span id="#1"></span>
### 了解AQS
AQS 提供了两种锁，分别是独占锁和共享锁。
- 独占锁，线程间互斥的独占操作，比如 ReentrantLock。
- 共享锁，多个线程共享操作直到触发场景条件，比如 CountDownLatch 和 Semaphore 等同步工具。

<span id="#2"></span>
### AQS实现基础
**锁的同步状态state ：**
- 由实现类操作state，利用state实现不同场景，AQS自身不操作改变state。
- 独占锁（以ReentrantLock为例）
    - 当state > 0 为有锁状态，当前线程每次重入加锁 state加 1，即代表当前持有锁的线程加了 state 次锁，反之解锁时每次减一；有锁状态下AQS处理其他线程入队（链表）等待。
    - 当 statte = 0 为无锁状态。
- 共享锁
    - 不同场景state的用法不一样。

**节点的状态waitStatus：**
- CANCELLED（1）：取消状态，如果当前线程的前置节点状态为 CANCELLED，则表明前置节点已经等待超时或者已经被中断了，这时需要将其从等待队列中删除。
- SIGNAL（-1）：等待触发状态，如果当前线程的前置节点状态为 SIGNAL，则表明当前线程需要阻塞。
- CONDITION（-2）：等待条件状态，表示当前节点在等待 condition，即在 condition 队列中。
- PROPAGATE（-3）：状态需要向后传播，表示 releaseShared 需要被传播给后续节点，仅在共享锁模式下使用。
- 0（0）：以上都不是。

**AQS 的结构大概可总结为以下 3 部分：**
- 用 volatile 修饰的整数类型的 state 状态，用于表示同步状态，提供 getState 和 setState 来操作同步状态；
- 提供了一个 FIFO 等待队列，实现线程间的竞争和等待，这是 AQS 的核心；
- AQS 内部提供了各种基于 CAS 原子操作方法，如 compareAndSetState 方法，并且提供了锁操作的acquire和release方法。

<span id="#3"></span>
### 独占锁实现
**独占锁获取锁：**
1. 尝试获取锁tryAcquire，成功则返回（ReentrantLock会操作state加1），否则添加节点到链表；
2. 尾节点为空时，new Node()空节点初始化为头尾节点，并加入当前线程节点至尾节点；
3. 尾节点不为空时，当前线程节点CAS操作加入尾节点，自旋直至成功；
（加入尾节点的过程需要CAS+自旋，头节点可能被抢先初始化、前置节点可能被释放）
4. 添加完节点，从队列自旋获取锁，当前线程节点的前置节点是头节点时，尝试获取锁（头节点可能刚好释放锁），失败或前置非头节点则挂起等待（线程中断或超时时取消节点，如果前置节点已被取消，则移除节点前已被取消的节点，继续自旋）；
5. 释放锁唤起线程继续第4步的自旋；
6. 锁状态state为0时获取锁成功，state加1，移除头节点；
7. 当异常跳出自旋，取消节点。

**独占锁释放锁：**
1. 尝试释放锁tryRelease，实现类操作state（ReentrantLock会操作state减1）；
2. 锁状态state为0时，释放成功，处理唤醒节点线程；
3. 当头节点头节点不为空且状态waitStatus不为0时（标注1），进入唤醒；
4. 当头节点状态waitStatus小于0时则设置为0，将头节点的后继节点唤醒，如果后继节点为空或已被取消，则从尾节点向前遍历到最后一个可唤醒节点。
> 标注1：个人理解，不唤醒初始化状态头节点的后继节点，分析代码也不会冲突，但没必要。第一次锁等待时，头尾节点为同一个初始化节点，并立即自旋尝试获取锁，第一次尝试未成功也会修改waitStatus为SIGNAL，只有在前置节点状态是SIGNAL时后继节点才会挂起。因此，头节点状态是0时，后继节点还没挂起，甚至正在加入链表。


<span id="#4"></span>
### 共享锁实现
**共享锁获取锁：**
1. 尝试获取锁tryAcquireShared，成功则返回（视场景而定），否则添加节点到链表；
2. 同独占锁获取锁的步骤2/3/4/5；
3. 不同场景不同实现，尝试获取锁满足条件时成功，移除头节点，当需要向后传播时，释放共享锁唤醒节点线程，成功则可继续唤醒节点线程（标注2）（标注3）。
4. 当异常跳出自旋，取消节点。
> 标注2：因为唤醒节点，传播并发唤醒，唤醒的节点可能抢先移除头节点；
> 标注3：例如信号量一次性释放n个，则需传播唤醒链表中的节点:

**共享锁释放锁：**
1. 尝试释放锁tryReleaseShared，成功（视场景而定）则唤醒链表中节点；
2. 唤醒头节点线程，尝试获取锁去修改锁状态state；
3. 成功则可继续唤醒节点线程（标注2）。

**一些共享锁实现的原理：**
- 读写锁：
1. 以锁状态state的高16位保存读锁状态，低16位保存写锁状态；
2. 读锁是共享锁，读读不互斥，高16位保存读锁获取数，当低16位大于0且不是当前线程时，存在写锁互斥；
- 闭锁：
1. 以锁状态state保存闭锁count数目；
2. 每一次await创建线程节点添加至共享锁等待链表，并挂起等待；
3. 每一次countDown仅处理state减1，为0时唤醒等待线程，并传播唤醒所有等待节点；
- 信号量：
1. 锁状态state保存可用的信号量数目；
2. 每一次acquire处理state减n，当state等于0时不处理减1，为0时才创建线程节点添加至共享锁等待链表，并挂起等待；
3. 每一次release处理state加n，唤醒等待线程，并传播唤醒所有等待节点，仅有n能成功，其他继续挂起；

<span id="#5"></span>
### 独占锁与共享锁最大的区别
1.  独占锁是唤醒线程抢占锁排斥继续工作，头节点表示成功抢占锁的工作线程；
2. 共享锁是唤醒线程释放节点，让锁状态state能够满足场景条件而继续工作；

<span id="#6"></span>
### 获取锁的一些区别
- 默认获取锁：当线程被中断，设置中断标志，不会抛出异常；
- 可中断获取锁：当线程被中断，抛出中断异常；
- 可超时获取锁：当线程等待超时，返回false，当线程被中断，抛出中断异常；

<span id="#7"></span>
### 条件协作
用于独占锁，挂起线程并释放锁。
- ConditionObject.await
1. 创建线程节点加入条件等待链表；
2. 一次性释放state为0（每次重入锁state加1），即释放锁；
3. 挂起线程，等待signal把线程节点加入等待链表；
4. 线程被唤醒后，执行获取独占锁，一次性把state加回去。
- ConditionObject.signal
1. 取出条件对象中的第一个线程节点，加入锁等待链表；
2. 如果前置节点被取消，或状态被改，唤醒当前线程继续执行await（标注4）；
> 标注4：个人理解，处理前置节点线程被中断取消的情况，提前唤醒线程执行获取独占锁，清除被取消的节点。

<span id="#8"></span>
### 链表入队实现
1. 创建当前线程节点；
2. 为了更快，先判断链表不为空时，直接入队（这里的快只是少了个循环指令吧，源码注释// Try the fast path of enq）；
3. 当链表为空时，初始化链表，头节点为无线程的new Node()（可理解为持有锁正在执行的线程，但不知道是谁，反正就是要排在它后面）；
4. 当链表不为空时，直接入队；






by xuyuanfa

