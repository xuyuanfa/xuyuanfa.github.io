---
title: 同步锁总结篇
categories:
- Java
tags:
- JUC
- 同步锁
---




- [自旋锁](##1)
- [synchronized内置锁](##2)
- [volatile原子变量](##3)
- [ReentrantLock](##4)
- [ReentrantReadWriteLock](##5)
- [AbstractQueuedSynchronizer](##6)
- [JUC同步辅助类](##7)
- [LockSupport](##8)
<!--more-->


<span id="#1"></span>
### 自旋锁
- 自旋锁是指当一个线程尝试获取某个锁时，如果该锁已被其他线程占用，就一直循环检测锁是否被释放，而不是进入线程挂起或睡眠状态。
- 自旋锁适用于锁保护的临界区很小的情况，临界区很小的话，锁占用的时间就很短。
- 自旋锁（Spin lock）、排队自旋锁（TargetLock）、MCS锁（MCSLock）、CLH锁（CLHLock）

**简单自旋锁**
```
public class SpinLock {
    private AtomicReference<Thread> owner = new AtomicReference<Thread>();
    public void lock() {
        Thread currentThread = Thread.currentThread();
        // 如果锁未被占用，则设置当前线程为锁的拥有者
        while (!owner.compareAndSet(null, currentThread)) {}
    }
    public void unlock() {
        Thread currentThread = Thread.currentThread();
        // 只有锁的拥有者才能释放锁
        owner.compareAndSet(currentThread, null);}
}
```
缺点：
- CAS操作需要硬件的配合；
- 保证各个CPU的缓存（L1、L2、L3、跨CPU Socket、主存）的数据一致性，通讯开销很大，在多处理器系统上更严重；
- 没法保证公平性，不保证等待进程/线程按照FIFO顺序获得锁。

**排队自旋锁**
有序的公平锁。
```
public class TicketLock {
    private AtomicInteger serviceNum = new AtomicInteger();
    private AtomicInteger ticketNum = new AtomicInteger();
    private static final ThreadLocal<Integer> LOCAL = new ThreadLocal<Integer>();
    public void lock() {
        int myticket = ticketNum.getAndIncrement();
        LOCAL.set(myticket);
        while (myticket != serviceNum.get()) {}
    }
    public void unlock() {
        int myticket = LOCAL.get();
        if (myticket == null) 
            return;
        serviceNum.compareAndSet(myticket, myticket + 1);
    }
}
```
缺点：
- Ticket Lock 虽然解决了公平性的问题，但是多处理器系统上，每个进程/线程占用的处理器都在读写同一个变量serviceNum ，每次读写操作都必须在多个处理器缓存之间进行缓存同步，这会导致繁重的系统总线和内存的流量，大大降低系统整体的性能。


**MCS锁**
MCS Spinlock 是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程只在本地变量上自旋，直接前驱负责通知其结束自旋，从而极大地减少了不必要的处理器缓存同步的次数，降低了总线和内存的开销。
```
    public class MCSLock {
        public static class MCSNode {
            volatile MCSNode next;
            volatile boolean isLocked = true;
        }
        private static final ThreadLocal<MCSNode> NODE = new ThreadLocal<MCSNode>();
        @SuppressWarnings("unused")
        private volatile MCSNode queue;
        private static final AtomicReferenceFieldUpdater<MCSLock, MCSNode> UPDATER = 
            AtomicReferenceFieldUpdater.newUpdater(MCSLock.class, MCSNode.class, "queue");
        public void lock() {
            MCSNode currentNode = new MCSNode();
            NODE.set(currentNode);
            MCSNode preNode = UPDATER.getAndSet(this, currentNode);
            if (preNode != null) {
                preNode.next = currentNode;
                while (currentNode.isLocked) {
                }
            }
        }
        public void unlock() {
            MCSNode currentNode = NODE.get();
            if (currentNode.next == null) {
                if (UPDATER.compareAndSet(this, currentNode, null)) {
                    // compareAndSet返回true表示确实没有人排在自己后面
                    return;
                } else {
                    // 在修改
                    while (currentNode.next == null) {
                    }
                }
            }
            currentNode.next.isLocked = false;
            currentNode.next = null;
        }
    }
```

**CLH锁**
CLH锁也是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程只在本地变量上自旋，它不断轮询前驱的状态，如果发现前驱释放了锁就结束自旋。
```
    public class CLHLock {
        public static class CLHNode {
            private volatile boolean isLocked = true;
        }
        @SuppressWarnings("unused")
        private volatile CLHNode tail;
        private static final ThreadLocal<CLHNode> LOCAL = new ThreadLocal<CLHNode>();
        private static final AtomicReferenceFieldUpdater<CLHLock, CLHNode> UPDATER = AtomicReferenceFieldUpdater
                .newUpdater(CLHLock.class, CLHNode.class, "tail");
        public void lock() {
            CLHNode node = new CLHNode();
            LOCAL.set(node);
            CLHNode preNode = UPDATER.getAndSet(this, node);
            if (preNode != null) {
                while (preNode.isLocked) {
                }
                preNode = null;
                LOCAL.set(node);
            }
        }
        public void unlock() {
            CLHNode node = LOCAL.get();
            if (!UPDATER.compareAndSet(this, node, null)) {
                node.isLocked = false;
            }
            node = null;
        }
    }
```

缺点：
- CLHlock是不停的查询前驱变量， 导致不适合在NUMA 架构下使用（在这种结构下，每个线程分布在不同的物理内存区域）

**NUMA架构简介**
由于所有CPU Core都是通过共享一个北桥来读取内存，随着核数不断的发展，北桥在响应时间上的性能瓶颈越来越明显。于是，聪明的硬件设计师们，先到了把内存控制器（原本北桥中读取内存的部分）也做个拆分，平分到了每个die上。于是NUMA就出现了！
http://cenalulu.github.io/linux/numa/


<span id="#2"></span>
### synchronized内置锁
1. 作为修饰符加在方法声明上, synchronized修饰非静态方法时表示锁住了调用该方法的堆对象（相对于synchronized(this)）, 修饰静态方法时表示锁住了这个类在方法区中的类对象（相对于synchronized(X.class)）；
2. synchronized(X.class) 使用类对象作为monitor. 同一时间只有一个线程可以能访问块中资源
3. synchronized(this)和synchronized(mutex) 都是对象锁, 同一时间每个实例都保证只能有一个实例能访问块中资源；
```
public class SyncMethod {
    private int value = 0;
    private final Object mutex = new Object();

    public synchronized int incAndGet0() {
       return ++value;
    }

    public int incAndGet1() {
        synchronized(this){
            return ++value;
        }
    }

    public int incAndGet2() {
       synchronized(SyncMethod.class){
            return ++value;
        }
    }

    public int incAndGet3() {
       synchronized(mutex){
            return ++value;
        }
    }

    public static synchonrize int incAndGet4() {
       synchronized(mutex){
            return ++value;
        }
    }
}
```

<span id="#3"></span>
### volatile原子变量
synchronized的代码块是确保可见性和原子性的，volatile只能确保可见性。
当且仅当下面条件全部满足时, 才能使用volatile保证原子性：
- 对变量的写入操作不依赖于变量的当前值，或者能确保只有单个线程在更新
- 该变量不会与其他状态变量共同参与不变性条件中
**volatile两个语义**
a.保证此变量对所有线程的可见性；
b.禁止指令重排序优化；
- 保证原子性的规则
a.运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值；
b.变量不需要与其他的状态变量共同参与不变约束；
- 可见性指令实现
lock addl $0x0,(%esp)
addl $0x0,(%esp)把ESP寄存器的值加0；
lock前缀使本CPU的cache写入内存，该写入动作会引起别的CPU或内核无效化其cache；
通过这样的空操作，让volatile变量的修改对其他CPU立即可见。
- 指令重排序
是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应的电路单元处理；
lock addl $0x0,(%esp)指令把修改同步到内存时，所有之前的操作都已经执行完成，实现内存屏障的效果。


<span id="#4"></span>
### ReentrantLock
- ReentrantLock基于AbstractQueuedSynchronizer实现，并基于内部抽象类Sync实现了公平锁FairSync和非公平锁NonfairSync，默认非公平锁。
- 高级功能：等待可中断、公平锁、锁绑定多个条件。
- 性能因素，虚拟机在未来性能改进更加偏向于原生的synchronized，提倡优先考虑synchronized。

**Condition**

- Condition是被绑定到Lock上的，要创建一个Lock的Condition必须用newCondition()方法。
- 锁绑定多个条件，只需多次调用newCondition()方法。
- Condition的实例对象相对于Synchronized锁定的Object对象，可指定时间。
    - await()对应wait()
    - signal()对应notify()
    - signalAll()对应notifyAll()

<span id="#5"></span>
### ReentrantReadWriteLock
可重入的读写锁。
基于AQS实现，利用锁状态state实现读写锁：
1. 以锁状态state的高16位保存读锁状态，低16位保存写锁状态；
2. 读锁是共享锁，读读不互斥，高16位保存读锁获取数，当低16位大于0且不是当前线程时，存在写锁互斥；

源码分析:
读锁
```
public static class ReadLock implements Lock, java.io.Serializable  {
    private final Sync sync;
    protected ReadLock(ReentrantReadWriteLock lock) {
        sync = lock.sync;
    }
    public void lock() {
        sync.acquireShared(1);//共享锁
    }
    public void lockInterruptibly() throws InterruptedException {
        sync.acquireSharedInterruptibly(1);
    }
    public  boolean tryLock() {
        return sync.tryReadLock();
    }
    public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException {
        return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));
    }
    public  void unlock() {
        sync.releaseShared(1);
    }
    public Condition newCondition() {
        throw new UnsupportedOperationException();
    }
}
```
写锁
```
public static class WriteLock implements Lock, java.io.Serializable  {
    private final Sync sync;
    protected WriteLock(ReentrantReadWriteLock lock) {
        sync = lock.sync;
    }
    public void lock() {
        sync.acquire(1);//独占锁
    }
    public void lockInterruptibly() throws InterruptedException {
        sync.acquireInterruptibly(1);
    }
    public boolean tryLock( ) {
        return sync.tryWriteLock();
    }
    public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException {
        return sync.tryAcquireNanos(1, unit.toNanos(timeout));
    }
    public void unlock() {
        sync.release(1);
    }
    public Condition newCondition() {
        return sync.newCondition();
    }
    public boolean isHeldByCurrentThread() {
        return sync.isHeldExclusively();
    }
    public int getHoldCount() {
        return sync.getWriteHoldCount();
    }
}
```

- WriteLock是独占锁，和ReentrantLock里面的实现几乎相同，都是使用了AQS的acquire/release操作，锁状态state的使用不同。
- ReadLock是共享锁，当WriteLock有锁（锁状态state低16位大于0）发生读写互斥。
- AQS中的锁状态state字段（int类型，32位）用来描述有多少线程获持有锁。高位16位表示共享锁的数量，低位16位表示独占锁的数量（或者重入数量）。2^16-1=65536，所以共享锁和独占锁的数量最大只能是65535。

写入锁分析:
```
        protected final boolean tryAcquire(int acquires) {
            Thread current = Thread.currentThread();
            int c = getState();
            int w = exclusiveCount(c);
            if (c != 0) {
                // (Note: if c != 0 and w == 0 then shared count != 0)
                if (w == 0 || current != getExclusiveOwnerThread())
                    return false;
                if (w + exclusiveCount(acquires) > MAX_COUNT)
                    throw new Error("Maximum lock count exceeded");
                // Reentrant acquire
                setState(c + acquires);
                return true;
            }
            if (writerShouldBlock() ||
                !compareAndSetState(c, c + acquires))
                return false;
            setExclusiveOwnerThread(current);
            return true;
        }
```
- 该方法是写锁调用的获取独占锁方法。
- 锁状态不为0，写锁为0（此时存在读锁）或者独占锁持有线程不是当前线程，即会发生读写互斥返回false，或者写入锁的数量（重入数）大于65535就抛出一个Error异常。
- 锁状态为0，可能是锁刚好被释放而为0，如果读写锁是公平锁时，需要判断链表中是否有正在排队的线程节点，有则需要排队返回false；如果被其他线程抢先获取写锁则CAS失败返回false。
- 设置独占线程（写线程）为当前线程，返回true。

**读写锁特性**

- 重入性：读写锁允许同个线程按照请求锁的顺序重新获取读取锁或者写入锁。同个线程获取写入锁后可以再次获取读取锁，但获取读取锁后却不能获取写入锁。
- 锁降级：线程获取写入锁后可以获取读取锁，然后释放写入锁，这样就从写入锁变成了读取锁，从而实现锁降级的特性。
- 锁获取中断：读取锁和写入锁都支持获取锁期间被中断。这个和独占锁一致。
- 条件变量：写入锁提供了条件变量(Condition)的支持，这个和独占锁一致，但是读取锁却不允许获取条件变量，将得到一个UnsupportedOperationException异常。

<span id="#6"></span>
### AbstractQueuedSynchronizer
[AQS同步器原理分析](#7 )


<span id="#7"></span>
### JUC同步辅助类
1. Semaphore 信号量通常用来限制线程可以同时访问的（物理或逻辑）资源数量。
2. CountDownLatch 在完成一组正在其他线程中执行的操作之前，允许一个或多个线程一直阻塞。
3. CyclicBarrier 允许一组线程互相等待, 直到到达某个公共的屏障点 (common barrier point)。因为该 barrier在释放等待线程后可以重用，所以称它为循环的barrier。
4. Phaser 一种可重用的同步屏障，功能上类似于CyclicBarrier和CountDownLatch，但使用上更为灵活。非常适用于在多线程环境下同步协调分阶段计算任务（Fork/Join框架中的子任务之间需同步时，优先使用Phaser）。
5. Exchanger 允许两个线程在某个汇合点交换对象，在某些管道设计时比较有用。Exchanger提供了一个同步点，在这个同步点一对线程可以交换数据。


<span id="#8"></span>
### LockSupport
- LockSupport是用来创建锁和其他同步类的基本线程阻塞原语。
- LockSupport中的park() 和 unpark() 的作用分别是阻塞线程和解除阻塞线程。
> 阻塞与解除阻塞
> JSR166以前还没有好的阻塞和解除阻塞线程的API可以使用！只有Thread.suspend 和 Thread.resume，但这两个方法已经被废弃了，原因是有可能导致死锁。如果一个线程拥有监视器然后调用Thread.suspend使自已阻塞，另一个线程试图调用Thread.resume去唤醒它，那么这个线程去获取监视器时即出现死锁。直到后来出现的LockSupport解决了这个问题。
> LockSupport.park可以阻塞一个线程，LockSupport.unpark可以解除阻塞，调用一次park，然后调用多次unpark只会唤醒一个线程，阻塞针对线程而不是针对同步器。特别的，如果一个线程在一个新的同步器上调用park方法有可能立即返回，因为可能有剩余的unpack存在。虽然调用多次unpark是想彻底清除阻塞状态，但这显得很笨拙，而且不划算，更有效的做法是在多次park的时候才多次unpark.

- LockSupport 与Thread.suspend()和Thread.resume()的区别 
在LockSupport出现之前，如果要block/unblock某个Thread，除了使用Java语言内置的monitor机制之外，只能通过Thread.suspend()和Thread.resume()。目前这两个方法都被标注为废弃。













http://coderbee.net/index.php/concurrent/20131115/577
http://zhwbqd.github.io/2015/02/13/lock-in-java.html
http://alexander-mahone.iteye.com/blog/1841134




by xuyuanfa
