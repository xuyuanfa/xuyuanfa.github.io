---
title: JVM虚拟机浓缩篇
categories:
- Java
tags:
- JVM
---

- [内存分配区域](##1)
- [GC垃圾收集](##2)
- [JMM内存模型](##3)
<!--more-->

<span id="#1"></span>
### 内存分配区域
**程序计数器**

- 当前线程所执行的字节码的行号指示器，在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选择下一条需要执行的字节码指令。
- 线程私有。

**Java虚拟机栈**

- Java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。
- 局部变量表存放了编译器可知的各种基本数据类型、对象引用和returnAddress类型（指向了一条字节码指令的地址）。
- 线程私有。

**本地方法栈**

- 虚拟机栈为虚拟机指向Java方法（也就是字节码）服务，而本地方法栈则为细腻及使用到的Native方法服务。
- 线程私有。

**Java堆**

- 被所有线程共享的一块内存区域，在虚拟机启动时创建。
- 存放对象实例。
- 垃圾收集器管理的主要区域，现在收集器级别都采用分代收集算法。
- 线程共享。

**方法区**

- 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
- 别名“Non-Heap”（非堆），目的与Java堆区分。
- 垃圾收集主要收集两部分内容：废弃常量和无用的类。
- 线程共享。

其中，程序计数器、虚拟机栈。本地方法栈3个区域随线程而生或灭。


<span id="#2"></span>
### GC垃圾收集
**对象存活判断**

- 引用计数算法：存在相互循环引用问题；
- 可达性分析算法：宣告一个对象死亡，至少经历两次标记，可在finalize()中拯救自己。

**垃圾收集算法**

- 标记清除：效率不高，空间碎片；
- 复制算法：预留一块空间；
- 标记整理：标记回收对象，移动存活对象，清理边界外的内存；
- 分代收集：新生代大批量死去选用复制算法，老年代存活率高选用标记清除或标记整理算法；

**内存分配及回收策略**

1. HotSpot虚拟机默认Eden区和Survivor区比例是8:1:1
2. 对象优先在Eden区中分配，不够空间时虚拟机发起一次Minor GC，把存活对象转移到另一块Survivor，GC期间Survivor无法容纳的对象直接进入老年代，通过分配担保机制提前转移到老年代去。
3. 大对象直接进入老年代，-XX:PretenureSizeThreshold参数可配置大于这个设置值的对象直接进入老年代。
4. 长期存活对象将进入老年代，对象在Survivor区中每熬过一次Minor GC，年龄加1岁，当达到一定程度（默认为15岁），就转移到老年代。-XX:MaxTenuringThreshold设置年龄阀值。
5. 如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold设置的值。

**进入老年代的条件**

1. Survivor无法容纳的对象直接进入老年代
2. 大对象直接进入老年代，参数配置-XX:PretenureSizeThreshold
3. 长期标记存活进入老年代，参数配置-XX:MaxTenuringThreshold设置年龄阀值
4. 相同年龄超过Survivor空间的一半，大于等于该年龄的对象提前进入老年代

**触发GC**

- Minor GC，当Eden区没有足够的空间进行分配时，虚拟机发起一次Minor GC。
- Full GC，JDK6 Update24之后，只要老年代最大可用的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC。


<span id="#3"></span>
### JMM内存模型
- 线程-本地内存-主内存，之间的关系，本地内存存储共享变量的副本，本地内存是抽象概念并不存在，它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。
- JMM通过控制主内存与每个线程的本地内存之间的交互，来为java程序员提供内存可见性保证。
- 从java源代码到最终实际执行的指令序列，会分别经历下面三种重排序：

1. 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
2. 指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
3. 内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行



by xuyuanfa